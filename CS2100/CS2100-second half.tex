\documentclass[12pt, landscape]{article}
\usepackage[scaled=0.92]{helvet}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
% \usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[landscape]{geometry}
%\usepackage{hyperref}

\usepackage{newtxtext} 

%for strikeout
\usepackage{ulem}

%For editing parbox
\usepackage[table]{xcolor}
%For editing itemise margins, reduce iterm separaion and list separation
\usepackage{enumitem}
% For math
\usepackage{amsmath,amsthm,amsfonts,amssymb}

%For pictures / figures
\usepackage{color,graphicx,overpic}
\graphicspath{ {./images/} }

%\usepackage{newtxtext} 
%\usepackage{amssymb}
%\usepackage[table]{xcolor}
%\usepackage{vwcol}
%\usepackage{tikz}
%\usepackage{wrapfig}
%\usepackage{makecell}


% For Code Blocks
\usepackage{xcolor}
\usepackage{listings}

% C++ Code Blocks:
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\definecolor{Darkgreen}{rgb}{0,0.4,0}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=4,    
%   rulecolor=,
    language=[GNU]C++,
        basicstyle=\tiny,
        upquote=true,
        aboveskip={0.5\baselineskip},
	% Represents top margin
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
	% Remove Numbers
        numbers=none,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        % numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%        \lstdefinestyle{C++}{language=C++,style=numbers}’.
}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  % Remove Numbers
  numbers=none,
  numberstyle=\tiny,
  numbersep=3 pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\tiny,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color{Darkgreen},
  stringstyle=\color{red}
}
% \lstset{language=C++}
%% Different languages: SQL, C++, Python


%Helpful:
%[linewidth = 1.0 \linewidth]
%\lstinline{}
% use \code{} for \lstinline with colorbox.
\newcommand{\code}[1]{\colorbox{gray!25!}{\lstinline[basicstyle=\scriptsize]|#1|}}

% Template: Cheatsheet with code enabled

%--------------------------- PACKAGES ABOVE --------------------------------------------------------------

\pdfinfo{
  /Title (CS2100 Summary.pdf)
  /Creator (Ger Teck)
  /Author (Ger Teck)
  /Subject ()
  /Keywords (tex)}

%% Margins for PAPER

% This sets page margins to .5 inch if using letter paper, and to 1cm
% if using A4 paper. (This probably isn't strictly necessary.)
% If using another size paper, use default 1cm margins.
\ifthenelse{\lengthtest { \paperwidth = 11in}}
	{ \geometry{top=.3in,left=.3in,right=.3in,bottom=.3in} }
	{\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
		{\geometry{top=0.5cm,left=0.5cm,right=0.5cm,bottom=0.5cm} }
		{\geometry{top=0.5cm,left=0.5cm,right=0.5cm,bottom=0.5cm} }
	}

% Turn off header and footer
\pagestyle{empty}

% for tight centres (less spacing)
\newenvironment{tightcenter}{%
  \setlength\topsep{0.5pt}
  \setlength\parskip{0.5pt}
  \begin{center}
}{%
  \end{center}
}

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
% change font
%\renewcommand{\familydefault}{\sfdefault}
%\renewcommand\rmdefault{\sfdefault}
\linespread{1.05}

\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}

%% this changes all items (enumerate and itemize, reduce margins) ITEMIZE SEPARATION HERE
\setlength{\leftmargini}{0.5cm}
\setlength{\leftmarginii}{0.5cm}
\setlist[itemize,1]{leftmargin=2mm,labelindent=1mm,labelsep=1mm, itemsep = 0mm}
\setlist[itemize,2]{leftmargin=4mm,labelindent=1mm,labelsep=1mm, itemsep = 0mm}
%itemsep = 0mm
%\setlist{nosep}

% Need Logo Picture
%Watermark Top Right
%\usepackage{atbegshi,picture}
%\AtBeginShipout{\AtBeginShipoutUpperLeft{%
 % \put(\dimexpr\paperwidth-1.2cm\relax, -1.2cm){\makebox[0pt][r]{\framebox{\includegraphics[width = 0.3cm]{mountainbooks} Ger Teck}}}%
%}}

% Justify Package
\usepackage[document]{ragged2e}

% -------------------------------------------------------------------------------

% START OF DOCUMENT HERE

\begin{document}
\raggedright
\footnotesize
\begin{multicols*}{3}



% multicol parameters
% These lengths are set only within the two main columns
%\setlength{\columnseprule}{0.25pt}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

%% DOCUMENT NAME HERE
\begin{center}
     \Large{\textbf{CS2100 Comp Org Notes}} \\
\end{center}
AY23/24 Sem 1, github.com/gerteck

\section{12. Boolean Algebra}
\subsubsection{Digital Circuits}
\begin{itemize}
\item Two voltage levels, 1 for high, 0 for low.
\item Digital circuits over analog circuits are more reliable, specified accurarcy (determinable).
\item Digital circuits abstracted using simple mathematical model: \textbf{(Boolean Algebra)}
\item Design, Analysis and simplification of digital circuit: \textbf{Digital Logic Design.}
\item \textbf{Combinational}: no memory, output depends solely on the input. (gates, adders, multiplexers)
\item \textbf{Sequential:} with memory, output depends on both input and current state. (counters, registers, memories)
\end{itemize}

\subsubsection{Boolean Algebra}
connectives in order of precedence:
\begin{itemize}
\item \textbf{negation} $A'$ equivalent to \textbf{NOT}
\item \textbf{conjunction} $A \cdot B $ equivalent to \textbf{AND}
\item \textbf{disjunction} $ A + B $ equivalent to \textbf{OR}
\item Note: always write the AND operator $ \cdot $, do not omit, as it may be confused with a 2 bit value, $AB$.
\item \textbf{Truth Table}: Provides listing of every possible combination of inputs and corresponding outputs. We may prove using truth table by comparing columns.
\end{itemize}

\subsubsection{Duality}
\begin{itemize}
\item \textbf{Duality}: if the AND/OR operators and identity elements 0/1 interchanged in a boolean equation, it remains valid.
\item e.g. the dual equation of $a+(b\cdot c)=(a+b)\cdot(a+c)$ is  $a\cdot(b+c)=(a\cdot b)+(a\cdot c).$, where if one is valid, then its dual is also valid.
\end{itemize}



\subsubsection{Laws \& Theorems of Boolean Algebra}
\centerline{\includegraphics[width=1\linewidth]{BAlaw1}}
\bigskip
\centerline{\includegraphics[width=1\linewidth]{BAlaw2}}
left/right equations are duals of each other

\subsubsection{Proving Theorems}
\begin{itemize}
\item Theorems can be proved using truth table, or by 
algebraic manipulation using other theorems/laws.
\end{itemize}
\centerline{\includegraphics[width=0.5\linewidth]{prove}}

\subsubsection{Boolean Functions, Complements}
\begin{itemize}
\item Represented by $F$, e.g. $F1(x,y,z) = x\cdot y\cdot z'$.
\item To prove $F1 = F2$, we may use boolean algebra, or use truth tables.
\item Complement Function is denoted as $F'$, obtained by interchanging 1 with 0 in function's output values.
\end{itemize}

% \vfill \null
\columnbreak

\subsubsection{Standard Forms}
\begin{itemize}
\item \textbf{Literals}: A Boolean variable on its own or in its complemented form. (e.g. $x$, $x'$)
\item \textbf{Product Term}: A single literal or a logical product (AND, $\cdot$) of several literals. (e.g. $x$, $x \cdot y \cdot z'$ )
\item \textbf{Sum Term}: A single literal or a logical sum (OR $+$) of several literals. (e.g. $A + B'$)
\item \textbf{sum-of-products (SOP) expression}: A product term or a logical sum (OR $+$) of several product terms.
\item \textbf{product-of-sums (POS) expression}: A sum term or a logical product (AND) of several sum terms.
\item Every boolean expr can be expressed in SOP/POS form.
\end{itemize}

\subsubsection{Minterms and Maxterms}
\begin{itemize}
\item \textbf{minterm} (of n variables): a product term that contains n literals from all the variables; denoted $m0$ to $m[2^n - 1]$
\item \textbf{maxterm} (of n variables): a sum term that contains n literals from all the variables; denoted $M0$ to $M[2^n - 1]$ 
\item Each minterm is the complement ($m2' = M2$) of its corresponding maxterm, vice versa.
\end{itemize}
\centerline{\includegraphics[width=0.5\linewidth]{minmax}}

\subsubsection{Canonical Forms}
\begin{itemize}
\item Canonical/normal form: a unique form of representation.
\item \textbf{Sum-of-minterms} = Canonical sum-of-products
\item \textbf{Product-of-maxterms} = Canonical product-of-sums
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{canon}}
• We can convert between sum-of-minterms and product-of-maxterms easily, by DeMorgan's.

\section{13. Logic Gates \& Simplification}
\subsubsection{Logic Gates}
\begin{itemize}
\item Fan-in: The number of inputs of a gate $\geq$ 1, 2. 
\item Implement bool exp / function as logic circuit.
\end{itemize}

\subsubsection{Universal Gates}
\begin{itemize}
\item \textbf{universal gate}: can implement a complete set of logic.
\item $\{AND, OR, NOT\}$ are a complete set of logic, sufficient for building any boolean function.
\item $\{NAND\}$ and $\{NOR\}$ themselves a complete set of logic. Implement NOT/AND/OR using only NAND or NOR gates.
\end{itemize}

\subsubsection{SOP and POS}
\begin{itemize}
\item an SOP expression can be easily implemented using \\
◦ 2-level AND-OR circuit or 2-level NAND circuit
\item a POS expression can be easily implemented using \\
◦ 2-level OR-AND circuit or 2-level NOR circuit
\end{itemize}

\subsubsection{Algebraic Simplification}
\begin{itemize}
\item \textbf{Function Simplification}: Make use of alegbraic (using theorems) or Karnaugh Maps (easier to use, limited to no more than 6 variables) or Quine-McCluskey.
\item \textbf{Algebraic Simplification}: aims to minimise \\
1. number of literals (prioritised over number of terms) \\
2. number of terms.
\end{itemize}

\subsubsection{Half Adder}
\begin{itemize}
\item Half adder is a circuit that adds 2 single bits (X, Y) to produce a result of 2 bits (C, S).
\centerline{\includegraphics[width=1\linewidth]{halfadder}}
\end{itemize}

\section{Universal Gates}
\centerline{\includegraphics[width=1\linewidth]{logicgates1}}
\bigskip
\centerline{\includegraphics[width=0.9\linewidth]{logicgates2}}

\columnbreak

\subsubsection{NAND as Universal Gate (Complete Logic Set)}
\centerline{\includegraphics[width=0.75\linewidth]{NAND}}
\smallskip
\subsubsection{NOR as Universal Gate  (Complete Logic Set)}
\centerline{\includegraphics[width=0.75\linewidth]{NOR}}


\subsubsection{Gray Code}
\begin{itemize}
\item Only a \textbf{single bit change} from one code value to the next. 4 bit standard gray code:
\centerline{\includegraphics[width=0.9\linewidth]{graycode}}
\item not restricted to decimal digits: $n$ bits can have up to $2^n$ values.
\item aka reflected binary code. To generate gray code, reflect.
\item not unique - multiple possible Gray code sequences
\end{itemize}

\subsubsection{K Maps}
\begin{itemize}
\item Simplify (SOP) expressions, with fewest possible product terms and literals.
\item Based on \textbf{Unifying Theorem ($A + A' = 1$), complement law.}
\item Abstract form of Venn diagram, matrix of squares, each square represents a \textbf{minterm}.
\item Two adjacent squares represent minterms that differ by exactly one literal.
\centerline{\includegraphics[width=1\linewidth]{kmap}}
\end{itemize}
\subsubsection{K Map for a function:}
\begin{itemize}
\item The K-map for a function is filled by putting: \\
◦ A \textbf{‘1’} in the square the corresponds to a \textbf{minterm} \\
◦ A ‘0’ otherwise
\item Each \textbf{valid grouping} of adjacent cells containing '1' corresponds to a
simpler product term. 
\item Group must have width/length (size) in \textbf{powers of 2}.
\item \textbf{larger group} = fewer literals in result product term
\item \textbf{fewer groups} = fewer product terms in final SOP exp.
\item Group maximum cells, and select fewest groups.
\end{itemize}


\vfill \null
\columnbreak

\section{K-Maps}
\subsubsection{3-Variable}
\centerline{\includegraphics[width=0.7\linewidth]{3variable}}

\subsubsection{4-Variable}
\centerline{\includegraphics[width=0.8\linewidth]{4variable}}

\subsubsection{5-Variable}
\centerline{\includegraphics[width=1\linewidth]{5variable}}

\subsubsection{Valid Groupings}
\centerline{\includegraphics[width=1\linewidth]{validgroup}}

\subsubsection{6-Variable}
\centerline{\includegraphics[width=0.9\linewidth]{6variable}}


\subsubsection{Using a K-map}
\begin{itemize}
\item K-map of function easily filled in when function in sum-of-minterms form. 
\item If not in sum-of-minterms, convert into sum-of-products (SOP) form, expand SOP expr into sum-of-minterms, or fill directly based on SOP.
\end{itemize}

\subsubsection{(E)PIs}
\begin{itemize}
\item \textbf{implicant}: product term that could be used to cover minterms of the function.
\item \textbf{prime implicant}: a product term obtained by combining the maximum possible number of minterms from adjacent squares in the map.
\item \textbf{essential prime implicant}: a prime implicant that includes at least one minterm that is not covered by any other prime implicant
\end{itemize}

\subsubsection{K-maps to find POS}
\begin{itemize}
\item shortcut: group maxterms (0s) of given function
\item long way: 1. convert K-map of F to K-map of F' (by flipping 0/1s), 2. get SOP of F' POS=(SOP)'.
\end{itemize}

\subsubsection{Don't-Care Conditions}
• denoted $d$, e.g.: $F(A, B, C) = \sum m(3, 5, 6) + \sum d(0, 7)$



\section{14. Combinational Circuits}
\subsubsection{Combinational Circuits}
\begin{itemize}
\item Two classes of logic circuits, combinational and sequential.
\centerline{\includegraphics[width=0.8\linewidth]{logiccircuits}}
\item \textbf{Function analysis of combinational circuit (CC)}: Label inputs and outputs, obtain functions of intermediate points and draw the truth table. Deduce functionality.
\item \textbf{CC design methods}: gate-level (with logic gates) and block-level (with functional blocks, e.g. IC chip).
\item Goals: reduce cost, increase speed, design simplicity.
\end{itemize}

\subsubsection{Gate-Level (SSI: Small Scale Integration) Design}
\begin{itemize}
\item Design procedure: \\
1. State problem, label input output of circuit.\\
2. Draw truth table, obtain simplified boolean function. \\
3. Draw logic diagram.
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{buildha}}
\bigskip
\centerline{\includegraphics[width=1\linewidth]{buildfa}}

\subsubsection{Arithmetic Circuits Summary}
\begin{itemize}
\item \textbf{Block-Level Design} More complex circuits built using block-level method, rely on algorithm or formulae of circuit, 
decompose problem into solvable subproblems.
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{ha}}
\bigskip
\centerline{\includegraphics[width=1\linewidth]{fa}}
\bigskip
\centerline{\includegraphics[width=1\linewidth]{4badder}}

\subsubsection{Circuit Delays}
\begin{itemize}
\item Given a \textbf{logic gate} with delay $t$. If inputs stable at times $t1, t2, …, tn,$ then earliest time in which 
output will be stable is: $max( t1, t2, …, tn ) + t$  \\ \medskip
\centerline{\includegraphics[width=0.8\linewidth]{circuitdelay}}
\item delay of a combinational circuit: repeat for all gates
\item E.g. n-bit parallel adder will have delay of: \\
$S_n = ( (n – 1) * 2 + 2 ) t $ \\
$C_{n+1} = ( (n – 1) * 2 + 3 ) t $ \\
\textbf{max delay} = $( (n – 1)* 2 + 3 ) t$
\end{itemize}


\columnbreak

\subsubsection{Block Diagrams}
\centerline{\includegraphics[width=0.8\linewidth]{block1}}

\subsubsection{MSI circuits Block Diagrams}
\centerline{\includegraphics[width=0.8\linewidth]{msiblock}}


\columnbreak

\section{15. MSI Components}
\subsubsection{Integrated Circuit}
\begin{itemize}
\item \textbf{IC} aka chip or microchip is a set of electronic circuits on small flat piece of semiconductor.
\item \textbf{Scale of Integration}: No. of components on standard size IC. (SSI: Small-scale Integration, MSI: Medium, LSI: Large, VLSI: Very large, ULSI: Ultra-large).
\end{itemize}

\subsubsection{Decoders}
\begin{itemize}
\item convert binary information from $n$ input lines, to up to $2^n$ output lines
\item selects only one output line, aka $n$-to-$m$-line decoder, $n:m$ or $n x m$ decoder where $m \leq 2^n$.
\centerline{\includegraphics[width=1\linewidth]{decoder}}
\end{itemize}

\subsubsection{Encoders}
\begin{itemize}
\item given a set of input lines, of which exactly one is high and the rest are low, provide code that corresponds to the high input line.
\item opposite of decoder. $\leq 2^n$ input lines and n output lines
\item implemented with OR gates
\centerline{\includegraphics[width=0.8\linewidth]{encoder}}
\end{itemize}

\subsubsection{Priority Encoders}
\begin{itemize}
\item If multiple inputs are equal to 1, the highest \textbf{priority} takes precedence
\item all inputs 0: invalid input
\centerline{\includegraphics[width=0.7\linewidth]{pencoder}}
\end{itemize}

\subsubsection{Enable}
\begin{itemize}
\item \textbf{one-enable}: device is only activated when $E = 1$
\item \textbf{zero-enable:} device is only activated when $E = 0$, denoted or $E'$ or $\bar{E}$
\end{itemize}
\centerline{\includegraphics[width=0.7\linewidth]{enable}}

\subsubsection{Zero-Enable/Negated Outputs}
\begin{itemize}
\item \textbf{active-high outputs}: normal outputs (selected line is 1)
\item \textbf{active-low outputs}: negated outputs (selected line is 0)
\end{itemize}

\subsubsection{Implementing Functions with Decoders}
\begin{itemize}
\item any combinational circuit with inputs and outputs can be implemented with an $n:2^n$ decoder with $m$ OR gates.
\item \textbf{input}: bool function, in sum-of-minterms form
\item \textbf{output}: decoder for minterms, OR gate to form sum.
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{decoderfunction}}

\subsubsection{Multiplexers \& Demultiplexers}
\centerline{\includegraphics[width=0.5\linewidth]{mudemu}}
\begin{itemize}
\item Helps share \textbf{single comm line} among devices.
\item One source, one dest at a time. (Circuit switching)
\end{itemize}

\subsubsection{Demultiplexer}
\begin{itemize}
\item directs data from the input line to \textbf{one} selected output line
\item input: an input line and set of selection lines
\item "output": directs data to one selected line
\item \textbf{Identical} to a \textbf{decoder with enable}
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{demux}}

\subsubsection{Multiplexer}
\begin{itemize}
\item steers one of $2^n$ input lines to single output line, using selection lines.
\item \textbf{input}: multiple input lines, multiple selection lines
\item \textbf{output}: one output line $=$ sum of the (product of \underline{data lines} and \underline{selection lines})
\item  Larger multiplexers can be constructed from smaller ones.
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{mux}}

\subsubsection{Implementing Functions with Multiplexers}
\begin{itemize}
\item A $2^n$-to-$1$ multiplexer can implement bool function of $n$ input variables:
\item Express in sum-of-minterms form.
\item Connect $n$ variables to $n$ selection lines, put ‘1’ on data line if minterm of function, ‘0’ otherwise
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{muxfun}}

\subsubsection{Using smaller multiplexers for Functions}
\begin{itemize}
\item We can use single smaller $2^{(n-1)}-to-1$ multiplexer to implement bool function of $n$ (input) variables.
\item \textbf{Procedure:} Express function in sum-of-minterms form, reserve one variable (here take least significant one) for input lines of multiplexer, and 
use rest for selection lines. (C for input, A \& B for selection)
\item Draw truth table for function, group inputs by selection line values, determine multiplexer inputs by comparing input line (C) and function (F).
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{smallermux}}

\vfill \null
\columnbreak

\section{16. Sequential Logic}
\begin{itemize}
\item \textbf{Sequential Circuit}: output depends on both \underline{present inputs} and  \underline{state}
\item 2 Types of sequential circuits: \\ 
\textbf{synchronous}: outputs change only at a specific time \\
\textbf{asynchronous}: outputs change at any time
\item Classes of sequential circuits: \\
\textbf{bistable}: 2 stable states (e.g. latches / flip-flops)
\textbf{monostable}: 1 stable state; astable, no stable state
\end{itemize}

\subsubsection{Latches}
\begin{itemize}
\item pulse-triggered (vs flipflops: edge-triggered)
\end{itemize}

\subsubsection{Flip-Flops}
\begin{itemize}
\item \textbf{synchronous bistable devices}: data on inputs is transferred to the flipflop's output only on the triggered edge of the clock pulse.
\item output changes state at a \underline{specific point on the clock}: \\
change state at either rising or falling edge of the clock signal
\end{itemize}

\subsection{Memory Elements}
\begin{itemize}
\item \textbf{Memory Elements}: Device which can remember value indefinitely, or change value on command from its inputs.
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{memoryelement}}
\subsection{Memory Elements with Clock}
\begin{itemize}
\item\textbf{pulse-triggered}: ON = 1, OFF = 0
\item \textbf{edge-triggered}:
\begin{enumerate}
\item \textbf{positive edge-trig}: ON: from 0 to 1, OFF: other t.
\item \textbf{negative edge-trig}: ON: from 1 to 0, OFF: other t.
\end{enumerate}
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{memoryelementclock}}

\subsection{Latches}
A Latch is a \textbf{sequential circuit} that watches all inputs continuously and changes output at any time \textbf{independently of a clocking signal}.

\subsubsection{S-R Latch}
\begin{itemize}
\item Two \textbf{Inputs}: $S$ (Set) and $R$ (Reset).
\item 2 complementary \textbf{outputs}: $Q$ and $Q'$
\item When $Q =$ high, latch is in SET state.
\item When $Q =$ low, latch is in RESET state.
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{SRlatch}}

\subsubsection{Gated S-R Latch}
\begin{itemize}
\item \textbf{S-R Latch + enable input (EN) + 2 NAND gates}
\item outputs change only when EN is high
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{gatedSRlatch}}

\subsubsection{Gated D Latch}
\begin{itemize}
\item \textbf{Gated D latch} make $R$ input equal to $S'$
\item eliminates undesirable condition of invalid state in the S-R latch.
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{gatedDlatch}}

\columnbreak

\subsection{Flip-flops}
Flip-flops changes its outputs only at times determined by a clocking signal. AKA basic digital memory circuit.

\subsubsection{S-R flip flop}
\begin{itemize}
\item $>$ symbol at clock input. Negative edge-trigger: $\circ>$. Outputs change at triggering edge of clock pulse. 
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{SRflipflop}}

\subsubsection{D flip flop}
\centerline{\includegraphics[width=1\linewidth]{dflipflop}}

\subsubsection{J-K flip flop}
\begin{itemize}
\item No valid state, Includes \textbf{toggle} state: $Q$ changes on each active clock edge.
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{jkflipflop}}

\subsubsection{T flip flop}
\begin{itemize}
\item \textbf{T flip-flop}: Single input version of the J-K flip-flop, formed 
by tying both inputs together.
\item $Q(t + 1) = T \oplus Q$
\end{itemize}

\centerline{\includegraphics[width=0.9\linewidth]{tflipflop}}

\section{Asynchronous Inputs}
\begin{itemize}
\item \textbf{asynchronous} inputs affect the state of the flip-flop independent of the clock.
\item e.g. J-K flip-flop with active-low PRESET and CLEAR asynchronous input
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{jkflipflopasync}} 
For \textbf{active-high}:
\begin{itemize}
\item PRE = 1 (HIGH): Q immediately set to HIGH
\item CLR = 1 (HIGH): Q immediately cleared to LOW
\item normal operation mode: both PRE and CLR are LOW
\end{itemize}

\section{Synchronous Sequential Circuits}
\begin{itemize}
\item Building blocks: \textbf{logic gates \& flip flops}. 
\item Flip-flops make up the memory, while gates form combinational sub-circuits.
\end{itemize}

 \null \null \null \null \null \null

\columnbreak

\subsection{Flip Flop Characteristic Tables}
\textbf{Characteristic tables} are used in analysis.
\centerline{\includegraphics[width=1\linewidth]{flipflopctable}} 

\subsection{Flip Flop Excitation Tables}
\textbf{Excitation tables} are used in design.
\centerline{\includegraphics[width=1\linewidth]{excitationtables}} 

 \null \null \null \null \null \null
 \null \null \null \null \null \null

\columnbreak

\section{17. Sequential Circuits Design}

\textbf{Sequential Circuits Design}: \textit{(from state equations/table/diagram to logic circuit).}
\begin{itemize}
\item For unused states, use \textbf{don't care X} for input.
\item \textbf{Self-correcting}: any unused state can transition to a used state after a finite number of cycles
\end{itemize}
\begin{enumerate}
\item Convert state diagram to state table.
\item fill in flip-flop inputs based on excitation table
\item use K-maps to get simplified logic expressions for flip-flop inputs (e.g.
JA, KA, JB, KB)
\item draw circuit implementing
\end{enumerate}

\subsubsection{Example}
\textbf{State diagram, design seq circuit with JK flip-flops}
\centerline{\includegraphics[width=1\linewidth]{sequentialcircuitsdesign}}

\columnbreak

\subsubsection{Unused States}
\begin{itemize}
\item use don't-care for input/next state/flip-flop inputs/output.
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{unusedstates}}


\subsection{Sequential Circuits Analysis}
\textit{(from logic circuit to state equations/table/diagram).}
\begin{enumerate}
\item obtain flip-flop input functions from the circuit
\item fill in the state table (using characteristic table)
\item draw state diagram
\end{enumerate}
\centerline{\includegraphics[width=0.8\linewidth]{analysis}}

\section{18. Memory}
\textbf{Memory}: stores programs and data.
\begin{itemize}
\item 1 byte: 8 bits; 1 word: multiple of bytes, usually size of register
\item memory unit stores binary info in words (groups of bits)
\item data consists of \underline{n lines} for n-bit words
\begin{itemize}
\item \textbf{data input lines}: provide info to write into memory
\item \textbf{data output lines}: carries info to be read from memory
\end{itemize}
\item \textbf{address} consists of \underline{k lines}
\begin{itemize}
\item specifies which word (of the words available) to be selected for
reading/writing
\end{itemize}
\item \textbf{control lines} R/W → specifies dierction of transfer of data
\end{itemize}

\subsubsection{Data Transfer}
\centerline{\includegraphics[width=0.8\linewidth]{Datatransfer}}

\subsubsection{Memory Unit, Read/Write Operations}
\centerline{\includegraphics[width=0.8\linewidth]{memoryunit}}
\textbf{Write}
\begin{itemize}
\item transfers address of the desired word to the address lines
\item transfers the word (data bits) to be stored in memory to the data input lines
\item activates the Write control (set R/W to 0)
\end{itemize}
\textbf{Read}
\begin{itemize}
\item transfers address of the desired word to the address lines
\item activates the Read control (set R/W to 1)
\end{itemize}

\subsubsection{Memory Cell, Memory Array}
\begin{itemize}
\item  \textbf{2 types of RAM}:
\item static RAMs: use flip-flops as the memory cells
\item dynamic RAMs: use capacitor charges to represent data
\item \textbf{Memory Arrays}: array of RAM chips, memory chips combined to form larger memory.
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{memorycell}}


\section{19. MIPS Pipelining}
\medskip
\begin{itemize}
\item \textbf{Pipelining} improves throughput of entire workload, but does not help latency of a single task.
\item Multiple tasks operating simultaneously using different resources.
\item Pipeline rate limited by slowest pipeline stage, stall for dependencies.
\item \textbf{Pipeline Implementation of MIPS:}
\begin{itemize}
	\item one cycle per pipeline stage.
	\item data required for each stage stored separately, as we need to carry data from one stage to next separately.
\end{itemize}
\end{itemize}

\subsection{MIPS Pipeline}
\begin{enumerate}
\item \code{IF} - instruction fetch
\item \code{ID} - instruction decode and register read
\item \code{EX} - execute an operation or calculate an address
\item \code{MEM} - access an operand in data mem
\item \code{WB} - write result back to a register
\end{enumerate}
\begin{itemize}
\item each stage is 1 clock cycle.
\item exceptions: updating PC and writing back to register file
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{pipelineStages}}

\columnbreak

\subsection{Pipeline Registers}
\begin{itemize}
\item Data used by same instruction in later pipeline stages are stored in pipeline registers.
\item Each pipeline register is a \underline{collection of registers}.
\item \textbf{Pipeline Registers}:
\item  \code{IF/ID} : register between IF and ID
\item  \code{ID/EX }: register between ID and EX
\item  \code{EX/MEM}: register between EX and MEM
\item  \code{MEM/WB}: register between MEM and WB
\item no register needed for the end of the WB stage
\end{itemize}

\centerline{\includegraphics[width=1\linewidth]{pipelineRegisters}}

\subsection{Pipeline Control}
\begin{itemize}
\item Same control signals as single-cycle datapath.
\item Each control signal belongs to a particular pipeline stage, avoid mixing up control from different pipelines.
\end{itemize}
\subsubsection{Control Grouping}
\begin{itemize}
\item Group control signals according to pipeline stage.
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{controlgrouping}}
\centerline{\includegraphics[width=0.9\linewidth]{controlgrouping2}}


\subsection{Pipeline Datapath}
\subsubsection{1. \code{IF} Stage}
\begin{itemize}
\item at end of a cycle, \code{IF/ID} \textbf{pipeline reg receives \& stores}:
\item ($PC + 4$) \& instruction from InstructionMemory[PC]
\end{itemize}

\subsection{2. \code{ID} Stage}
	\begin{multicols*}{2}
	\textbf{\code{IF/ID} register supplies:}
	\begin{itemize}
	\item 2 Register numbers for reading registers
	\item 16-bit offset to be sign-extended to 32-bit.
	\item $PC + 4$
	\end{itemize}
	\columnbreak
	    
	\textbf{\code{ID/EX} register receives:}
	\begin{itemize}
	\item Data values read \\ from reg file
	\item 32-bit immediate value
	\item $PC + 4$
	\end{itemize}
	\end{multicols*}

\subsection{3. \code{EX} Stage}
	\begin{multicols*}{2}
	\textbf{\code{ID/EX} register supplies:}
	\begin{itemize}
	\item Data values read from reg file
	\item 32-bit immediate value
	\item $PC + 4$
	\item + write register number
	\end{itemize}
	\columnbreak
	    
	\textbf{\code{EX/MEM} register receives:}
	\begin{itemize}
	\item $(PC + 4) + (Immd \times 4)$
	\item ALU result
	\item isZero? signal
	\item RD2 from register file
	\item + write register number
	\end{itemize}
	\end{multicols*}

\subsection{4. \code{MEM} Stage}
	\begin{multicols*}{2}
		\textbf{\code{EX/MEM} register supplies:}
		\begin{itemize}
		\item $(PC + 4) +  (Immd \times 4)$
		\item ALU result
		\item isZero? signal
		\item RD2 from register file
		\item + write register number
		\end{itemize}
	\columnbreak
	    
		\textbf{\code{MEM/WB} register receives:}
		\begin{itemize}
		\item ALU result
		\item mem read data
		\item + write register number
		\end{itemize}
				\vfill \null
	\end{multicols*}


\subsection{5. \code{WB} Stage}
	\begin{multicols*}{2}
		\textbf{\code{MEM/WB} register supplies:}
		\begin{itemize}
		\item ALU result
		\item mem read data
		\item write register number
		\end{itemize}
	\columnbreak
		\textbf{End of Cycle}: result is written back to register file if applicable.
		\vfill \null
	\end{multicols*}


\section{Pipeline Implementations}
\medskip
\centerline{\includegraphics[width=1\linewidth]{pipelineimplementations}}

\subsection{Performance Comparison of Implementations}
\begin{itemize}
\item $CT =$ cycle time
\item $T_K =$ time for operation in stage 
\item $N =$ number of stages
\end{itemize}

\subsection{single-cycle processor}
\begin{itemize}
\item cycle time: $CT_{seq}= max(\sum_{N}^{k=1} T_K)$
\item execution time for $I$ instructions $I \times CT_{seq}$
\end{itemize}

\subsection{multi-cycle processor}
\begin{itemize}
\item cycle time: $CT_{multi}= max(T_K)$
\item execution time for $I \times Average CPI \times CT_{multi}$ \\
\item (average CPI needed as each instr. takes diff no. of cycles.)
\end{itemize}

\subsection{pipelined processor}
\begin{itemize}
\item cycle time: $CT_{pipeline}= max(T_K) + T_d$
\item $T_d = $ overhead for pipelining (e.g. pipeline register)
\item cycles needed for $I$ instructions $= (I + N - 1)$
\item execution time for $I$ instructions $(I + N - 1) \times CT_{pipeline}$
\end{itemize}

\subsection{Pipelined Ideal Speedup}
\textbf{assumptions}:
\begin{itemize} 
\item Every stage takes same amount of time: $ \sum_{N}^{k=1} = N \times T_1$
\item No pipeline overhead $T_d = 0$
\item $I >> N$ (num. of instructions much larger num. of stages)
\end{itemize}

\centerline{$Speedup_{pipeline} = \frac{Time_{seq}}{Time_{pipeline}} = N$}

\columnbreak

\section{20. Pipeling Hazards}
\begin{itemize}
\item \textbf{Pipeline hazards} prevent next instruction from immediately following previous instruction.
\item \textbf{Structural Hazards}: simultaneous use of hardware resource.
\item \textbf{Data Hazards}: data dependencies between instructions.
\item \textbf{Control Hazards}: change in program flow.
\end{itemize}

\subsection{Structural Hazards}
\begin{itemize}
\item solves read/write conflict in MEM module.
\item split cycle into half.
\item first half: write into register
\item second half: read from register.
\end{itemize}
\centerline{\includegraphics[width=0.8\linewidth]{structuralhazard}}

\subsection{Data Hazards}
\begin{itemize}
\item instruction dependency: read-after-write (RAW)
\item WAR, WAW data dep. do not cause pipline hazards.
\end{itemize}
\subsubsection{Forwarding}
\begin{itemize}
\item forward data right after EX stage completed, bypass (replace) data read from register file.
\item usually no delay incurred
\end{itemize}
\centerline{\includegraphics[width=1\linewidth]{forwarding1}}

\begin{itemize}
\item for \code{lw}, data is only ready after MEM stage.
\item No choice, may incur extra 1 cycle delay.
\end{itemize}
\centerline{\includegraphics[width=0.7\linewidth]{stall1}}

\subsection{Control Hazards}
\begin{itemize}
\item branch decision (IM) made in MEM stage: \textbf{stall pipeline}
\item 3 cycles delay \textbf{(next IM starts after curr. MEM)}
\end{itemize}

\subsubsection{Early Branch Resolution}
\begin{itemize}
\item Make decision in ID stage instead of MEM.
\item Move branch target address calc \& reg comparison.
\centerline{\includegraphics[width=0.8\linewidth]{earlybranch1}}
\item 1 cycle delay
\centerline{\includegraphics[width=0.8\linewidth]{earlybranch2}}
\item 2 cycle delay if there is data dependency as well.
\item 2 cycle delay if \code{lw} occurs before branch (wait stage 4)
\end{itemize}

\subsubsection{Branch Prediction (assume branch not taken)}
\begin{itemize}
\item \textbf{if branch taken (prediction wrong):} \\
 stall 1 or 3 cycles depending on early branching.
\end{itemize}

\subsubsection{Delayed Branch}
\begin{itemize}
\item if branch outcome takes $X$ no. of cycles to be known, \textbf{move non-control
dependent} instr into the X slots following a branch.
\item aka branch delay slot ('no-op' nop slots), else fill w. nop.
\item instructions executed regardless of branch outcome
\end{itemize}

\columnbreak

\section{21. Cache}
\subsection{Memory Technology}
\begin{itemize}
\item \textbf{DDR SDRAM}: Double Data Rate - Synchronous Dynamic RAM, (E.g. DDR5), delivers memory on positive \& negative edge of clock (double rate), slower access latency.
\item DRAM capacity quadrupled almost every 3 years, DRAM access latency not keeping up. (50ns access DRAM, 1GHZ processor: 50 processor clock cycles per memory access).
\item \textbf{SRAM}: Static RAM, low density, fast access latency.
\item \textbf{Magnetic Disk}: Slow latency, large capacity.
\end{itemize}

\begin{itemize}
\item \textbf{Hierarchy of memory technologies}: put small but fast memory near CPU, large but slow memory farther away from CPU, to obtain illusion of big and fast memory.
\end{itemize}
\centerline{\includegraphics[width=0.9\linewidth]{memoryhierarchy}}

\subsubsection{Locality}
\begin{itemize}
\item \textbf{principle of locality}: program acccesses only a small portion of the memory address sapce within a small time interval.
\item \textbf{temporal locality}: If an item is referenced, it will tend to be referenced again soon (e.g. loop)
\item \textbf{spatial locality}: If an item is referenced, nearby items will tend to be referenced soon. (e.g. array)
\end{itemize}

\subsubsection{Working Set}
\begin{itemize}
\item \textbf{Set of locations} accessed during $\Delta$t.
\item \textbf{Aim}: capture the working set and keep it in the memory closest to CPU.
\end{itemize}
\centerline{\includegraphics[width=0.65\linewidth]{workingset}}


\subsection{Cache}
\textbf{Cache}: small but fast SRAM near CPU.
\centerline{\includegraphics[width=0.65\linewidth]{cache}}

\subsection{Memory Access Time}
\centerline{\includegraphics[width=0.55\linewidth]{MemoryAccessTime}}
\begin{itemize}
\item \textbf{Hit}: Data is in cache.
	\begin{itemize}
	\item \textbf{Hit rate}: Fraction of memory accesses that hit.
	\item \textbf{Hit time}: Time to access cache.
	\end{itemize}
\item \textbf{Miss}: Data is not in cache.
	\begin{itemize}
	\item \textbf{Miss rate}: $= 1 -$ Hit rate
	\item \textbf{Miss penalty}: Time to replace cache block $+$ hit time.
	\end{itemize}
\item Naturally, Hit time $<$ Miss penalty.
\item \textbf{Average Access Time}: 
\end{itemize}

\centerline{\textbf{average access time}}
\centerline{$=$ (hit rate $\times$ hit time) $+$ (miss rate $\times$ miss penalty)}

\subsection{Memory to Cache Mapping}
\begin{itemize}
\item \textbf{Cache Block/Line}: Unit of transfer btwn. mem \& cache.
\item Block size typically one or more words. (E.g. 16-byte block $\approx$ 4-word block, 32-byte block $\approx$ 8-word block)
\end{itemize}
\centerline{\includegraphics[width=0.95\linewidth]{memtoCache}}

\subsection{Block Size Trade-off}
Larger block size:
\begin{itemize}
\item $+$ takes advantage of spatial locality.
\item $-$ Larger miss penalty: takes longer time to fill up the block.
\item $-$ fewer cache blocks, miss rate goes up. (block size too big relative to cache size)
\end{itemize}
\centerline{\includegraphics[width=0.90\linewidth]{blocksize}}

\subsection{Multilevel Cache}
\begin{itemize}
\item Separate data and instruction caches (vs. unifed cache).
\end{itemize}
\centerline{\includegraphics[width=0.90\linewidth]{multiLevelCache}}
\medskip

Let $h$ be hit rate required to sustain average access time $t$, where SRAM cache has access time $s$ ns and DRAM cache has access time $d$ ns. \\ \smallskip

\centerline{$ t = (h * s) + (1 - h) \times (d + s)$}

\bigskip
\centerline{\includegraphics[width=0.8\linewidth]{cacheSummary1}}

\null \null
\columnbreak

\section{21.1 Direct Mapped Cache}
\begin{itemize}
\item \textbf{Cache Block}: Unit of transfer btwm mem \& cache.
\end{itemize}

\subsubsection{Direct Mapped Cache contains:}
\begin{itemize}
\item \textbf{valid bit} indicating if cache line contains valid data
\item \textbf{tag} of the memory block, and the data block.
\end{itemize}
	
\centerline{\includegraphics[width=0.9\linewidth]{cacheMemory}}
\begin{itemize}
\item If number of cache blocks $= 2^M$, last $M$ bits of block number is the \textbf{cache index} (which index it maps to).
\item Then, multiple memory blocks can map to same cache block. However, they have a unique \textbf{tag number}. (Preceding bits.) \\ \smallskip
\centerline{\textbf{Tag Num} $=$ BlockNum. $/$ Num.ofCacheBlocks}
\end{itemize}

\textbf{DM Mapping Function}
\begin{itemize}
\item Cache index $=$
\centerline{(BlockNumber) modulo (NumberofCacheBlocks)}
\end{itemize}
\centerline{\includegraphics[width=0.5\linewidth]{mapfun2}}
\smallskip
\centerline{\includegraphics[width=0.9\linewidth]{mapfun}}

\subsubsection{Memory Address Split}
\begin{itemize}
\item offset: which \underline{byte} within the block
\item index: which \underline{line} in the cache
\item tag: which \underline{block} is mapped to that line
\end{itemize}


\subsection{Cache Circuitry}
\centerline{\includegraphics[width=0.95\linewidth]{cacheCircuitry}}
\medskip
\centerline{\includegraphics[width=0.95\linewidth]{cacheMapping}}
\medskip
\centerline{\includegraphics[width=1\linewidth]{readWriteSummary}}

\null \null \null \null \null \null \null \null
\columnbreak
 
 
\subsection{Types of Cache Misses}
\begin{itemize}
\item \textbf{Compulsory miss}: on first access to block, block must be brought into cache. \\Aka \textbf{cold start misses / first reference misses}.
\medskip

\item \textbf{Conflict miss}: when several blocks mapped to same block/set, if same address is accessed. 
\\Aka \textbf{collision misses / interference misses}
\medskip

\item \textbf{Capacity miss}: when blocks are discarded from cache as cache cannot contain all blocks needed.
\end{itemize}

\subsection{Writing Data}
\begin{itemize}
	\item \textbf{Solution 1: Write-through cache} (write to both cache and main memory). 
		\begin{itemize}
		\item put write buffer between cache and main memory.
		\end{itemize}
	\item \textbf{Solution 2: Write-back cache} (only write to mem on block replace)
		\begin{itemize}
		\item add an additional \textbf{dirty bit} to each cache block, write op changes dirty bit to 1, only write back to memory if dirty bit is 1.
		\end{itemize}
\end{itemize}


\subsection{Handling Cache Misses}
\begin{itemize}
	\item On \textbf{Read Miss}:
		\begin{itemize}
		\item load data into cache, load from cache to register.
		\end{itemize}
	
	\item On \textbf{Write Miss}: (data to write no in cache)
		\begin{itemize}
		\item \textbf{option 1: write allocate}
			\begin{itemize}
			\item load the complete block into cache
			\item change only the required word in cache
			\item write policy decide write to main memory 
			\end{itemize}
		
		\item \textbf{option 2: write around}
			\begin{itemize}
			\item Do not load block to cache
			\item write directly to main memory, bypass cache
			\end{itemize}
		\end{itemize}
\end{itemize}

\null \null
\columnbreak
 
\section{21.2 Set Associative Cache}
\begin{itemize}
\item Tackles conflict misses.
\end{itemize}

\subsection{Set Associative Cache}
\begin{itemize}
	\item \textbf{N-way Set Associative Cache}: A memory block can be placed in a fixed number ($N$) of locations in the cache, where $N > 1$.
	\item Cache consists of a number of sets, each set contains $N$ cache blocks. Each memory block maps to a unique \textbf{cache set}, and can be placed in any of the $N$ cache blocks in the set.
	\item Need to search all blocks in set to look for memory block.
\end{itemize}
\centerline{\includegraphics[width=0.95\linewidth]{SACache1}}
 
\subsection{SA Mapping}
\begin{itemize}
\item Unchanged from direct-mapping formula.
\item Cache Set Index \\
\centerline{$=$ (BlockNumber) modulo (NumberOfCacheSets)}
\end{itemize}
\centerline{\includegraphics[width=0.7\linewidth]{SACacheMap}}
 
\subsubsection{Performance}
\begin{itemize}
\item A direct-mapped cache of size $N$ has about the same miss rate 
as a 2-way set associative cache of size $N/2$.
\end{itemize}

\columnbreak

\subsection{Circuitry}
\begin{enumerate}
\item Use address \textbf{Set Index} to identify set
\item for each block in set, check if valid bit $=$ 1 and check if tag matches tag in address.
\end{enumerate}
\centerline{\includegraphics[width=0.99\linewidth]{SACache2}}
 
\subsection{Block Replacement Policy}
\begin{itemize}
\item For SA/FA cache, choose where to place memory block.
\item \textbf{Least Recently Used (LRU)}: temporal locality.
\begin{itemize}
\item replace block that has not been accessed for longest time
\item hard to keep track if many choices.
\end{itemize}
\item \textbf{Other replacement policies}: First in first out (FIFO), Random replacement (RR), Least frequently used (LFU).
\end{itemize}


\section{21.3 Fully Associative Cache}
\subsection{Fully Associative Cache}
\begin{itemize}
\item \textbf{FA Cache}: a memory block can be placed in any location in the cache, not restricted.
\item No mapping function: (tag $=$ block number).
	\begin{itemize}
	\item $+$ memory block can be placed in any location
	\item $-$ need to search all cache blocks for memory access
	\item used for small cache 
	\end{itemize}
\item \textbf{No conflict miss}
\end{itemize}

\subsection{FA Mapping}
\centerline{\includegraphics[width=0.99\linewidth]{FAmap}}

\subsection{Circuitry}
\centerline{\includegraphics[width=0.90\linewidth]{FAcache}}
\medskip

\subsection{Performance of FA}
\begin{enumerate}
\item Cold/compulsory miss remains the same 
irrespective of cache size/associativity.
\item For same cache size, conflict miss goes 
down with increasing associativity.
\item Conflict miss $=$ 0 for FA caches.
\item For same cache size, capacity miss remains same irrespective of associativity.
\item Capacity miss decreases with increasing cache size 
\end{enumerate}

\centerline{total miss = cold miss $+$ conflict miss $+$ capacity miss}

\begin{itemize}
\item For FA, since conflict miss $=$ 0, \\ \smallskip
\centerline{capacity miss (FA) = total miss (FA) - cold miss (FA)}
\end{itemize}
\centerline{\includegraphics[width=0.6\linewidth]{cacheSummary2}}


\columnbreak
\section{22. Others}
\subsection{Units}
\begin{itemize}
\item 1 B = 1 byte = 8 bits = $2^3$ bits.
\item 1 KB = 1024 byte = $2^{10}$ bytes $= 2^{13}$  bits.
\item 1 MB = 1024 KB = $2^{20}$ bytes $= 2^{23}$ bits.
\item 1 GB = 1024 MB = $2^{30}$ bytes $= 2^{33}$ bits.
\item Useful way to find power: $log_2(X) = \frac{log_{10}(X)}{log_{10}(2)}$
\end{itemize}

\centerline{\includegraphics[width=0.6\linewidth]{powersoftwo}}
 
 
 
 
 
 
 
 
 
 
 
\end{multicols*}
\end{document}